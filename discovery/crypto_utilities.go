package discovery

// Note: These functions are taken from the sphinx.go file
// The sphinx module did not allow exporting these functions
// hence as a work around being copied here. Needs to be fixed
import (
	"crypto/hmac"
	"crypto/sha256"

	"github.com/aead/chacha20"
	"github.com/btcsuite/btcd/btcec"
)

const (

	// keyLen is the length of the keys used to generate cipher streams and
	// encrypt payloads. Since we use SHA256 to generate the keys, the
	// maximum length currently is 32 bytes.
	keyLen = 32
)

// Hash256 is a statically sized, 32-byte array, typically containing
// the output of a SHA256 hash.
type Hash256 [sha256.Size]byte

// GenerateSharedSecret wrapper function so that it can be exposed to other modules
func GenerateSharedSecret(pub *btcec.PublicKey, priv *btcec.PrivateKey) Hash256 {
	return generateSharedSecret(pub, priv)
}

// generateSharedSecret generates the shared secret for a particular hop. The
// shared secret is generated by taking the group element contained in the
// mix-header, and performing an ECDH operation with the node's long term onion
// key. We then take the _entire_ point generated by the ECDH operation,
// serialize that using a compressed format, then feed the raw bytes through a
// single SHA256 invocation.  The resulting value is the shared secret.
func generateSharedSecret(pub *btcec.PublicKey, priv *btcec.PrivateKey) Hash256 {
	s := &btcec.PublicKey{}
	x, y := btcec.S256().ScalarMult(pub.X, pub.Y, priv.D.Bytes())
	s.X = x
	s.Y = y

	return sha256.Sum256(s.SerializeCompressed())
}

// GenerateKey wrapper function so that it can be exposed to other modules
func GenerateKey(keyType string, sharedKey *Hash256) [keyLen]byte {
	return generateKey(keyType, sharedKey)
}

// generateKey generates a new key for usage in Sphinx packet
// construction/processing based off of the denoted keyType. Within Sphinx
// various keys are used within the same onion packet for padding generation,
// MAC generation, and encryption/decryption.
func generateKey(keyType string, sharedKey *Hash256) [keyLen]byte {
	mac := hmac.New(sha256.New, []byte(keyType))
	mac.Write(sharedKey[:])
	h := mac.Sum(nil)

	var key [keyLen]byte
	copy(key[:], h[:keyLen])

	return key
}

// GenerateCipherStream wrapper function so that it can be exposed to other modules
func GenerateCipherStream(key [keyLen]byte, numBytes uint) []byte {
	return generateCipherStream(key, numBytes)
}

// generateCipherStream generates a stream of cryptographic psuedo-random bytes
// intended to be used to encrypt a message using a one-time-pad like
// construction.
func generateCipherStream(key [keyLen]byte, numBytes uint) []byte {
	var (
		nonce [8]byte
	)
	cipher, err := chacha20.NewCipher(nonce[:], key[:])
	if err != nil {
		panic(err)
	}
	output := make([]byte, numBytes)
	cipher.XORKeyStream(output, output)

	return output
}

// Xor wrapper function so that it can be exposed to other modules
func Xor(dst, a, b []byte) int {
	return xor(dst, a, b)
}

// xor computes the byte wise XOR of a and b, storing the result in dst.
func xor(dst, a, b []byte) int {
	n := len(a)
	if len(b) < n {
		n = len(b)
	}
	for i := 0; i < n; i++ {
		dst[i] = a[i] ^ b[i]
	}
	return n
}
